<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Navon Task - jsPsych</title>
  <link href="https://unpkg.com/jspsych@6.3.1/css/jspsych.css" rel="stylesheet" type="text/css">
  <style>
    body {
      background-color: black;
      color: white;
      font-family: monospace;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    .navon-letter {
      font-size: 28px;
      font-family: monospace;
      display: inline-block;
      width: 28px;
      height: 28px;
      text-align: center;
      opacity: 0;
      animation: fadein 0.2s forwards;
    }

    @keyframes fadein {
      from { opacity: 0; transform: scale(0.5); }
      to { opacity: 1; transform: scale(1); }
    }
  </style>
</head>
<body>

<script src="https://unpkg.com/jspsych@6.3.1/jspsych.js"></script>
<script src="https://unpkg.com/jspsych@6.3.1/plugins/jspsych-html-keyboard-response.js"></script>

<script>

const GOOGLE_SHEETS_URL = "https://script.google.com/macros/s/AKfycby7A9h8umnjMCqZWWRiTLVGU5neywZ4saaPb6pKQoltcUtn1JeiK1UJ_6G5zbCPexCSLw/exec";

function generateParticipantID() {
  return "NAVON-" + Math.random().toString(36).substring(2, 8).toUpperCase();
}
const PARTICIPANT_ID = generateParticipantID();
const TIMESTAMP = new Date().toISOString();

jsPsych.data.addProperties({
  participant_id: PARTICIPANT_ID,
  timestamp: TIMESTAMP
});

const N_TRIALS_GLOBAL = 20;
const N_TRIALS_LOCAL  = 20;
const N_TRIALS_MIXED  = 40;
const GLOBAL_LETTERS = ["H", "S"];
const GRID_SIZE = 9;

const TEMPLATES = {
  "H":[
    [1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,1]
  ],
  "S":[
    [0,1,1,1,1,1,1,1,0],
    [1,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0,0],
    [0,0,1,1,1,1,1,0,0],
    [0,0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,1],
    [0,1,1,1,1,1,1,1,0]
  ]
};

function generateNavonHTML(global_letter, local_letter){
  let html = '<div style="display:inline-block;">';
  const template = TEMPLATES[global_letter];
  const colors = ["white", "yellow", "cyan", "magenta", "lime"];

  for(let r=0; r<GRID_SIZE; r++){
    html += '<div>';
    for(let c=0; c<GRID_SIZE; c++){
      if(template[r][c] === 1){
        const color = colors[Math.floor(Math.random()*colors.length)];
        html += `<span class="navon-letter" style="color:${color}">${local_letter}</span>`;
      } else {
        html += `<span class="navon-letter">&nbsp;</span>`;
      }
    }
    html += '</div>';
  }
  html += '</div>';
  return html;
}

function createTrials(block_type, n_trials, fixed_task=null){
  const trials = [];
  for(let i=0;i<n_trials;i++){
    let task = fixed_task || (block_type==="mixed" ? (Math.random()<0.5?"global":"local") : fixed_task);
    let condition = Math.random()<0.5 ? "congruent" : "incongruent";
    let global_letter, local_letter;

    if(condition==="congruent"){
      global_letter = local_letter = GLOBAL_LETTERS[Math.floor(Math.random()*2)];
    } else {
      const shuffled = [...GLOBAL_LETTERS].sort(()=>Math.random()-0.5);
      global_letter = shuffled[0];
      local_letter  = shuffled[1];
    }

    if(block_type==="mixed"){
      const cue = task==="global" ? "↑" : "↓";
      trials.push({
        type: "html-keyboard-response",
        stimulus: `<div style="font-size:80px; color:yellow;">${cue}</div>`,
        choices: jsPsych.NO_KEYS,
        trial_duration: 700,
        data: {ignore:true}
      });
    }

    trials.push({
      type: "html-keyboard-response",
      stimulus: generateNavonHTML(global_letter, local_letter),
      choices: ["1","2"],
      trial_duration: 1500,
      data: {
        block: block_type,
        trial: i+1,
        condition: condition,
        task: task,
        global_letter: global_letter,
        local_letter: local_letter
      },
      on_finish: function(data){
        const correct = (data.task==="global" && data.global_letter==="H") || 
                        (data.task==="local" && data.local_letter==="H") ? "1" : "2";
        data.correct = (data.response===correct)?1:0;
      }
    });
  }
  return trials;
}

let timeline = [];

timeline.push({
  type: "html-keyboard-response",
  stimulus: `
    <h2>Neivona uzdevums</h2>
    <p>Vēro burtus, kas parādīsies uz ekrāna.</p>
    <p>Atbildi: "H" = 1, "S" = 2</p>
    <p>Atbildes jāsniedz ātri, jo limits ir 1,5 sekundes.</p>
    <p>Nospied SPACE, lai sāktu eksperimentu.</p>
  `,
  choices: [" "],
  data: {ignore:true}
});

timeline.push({
  type: "html-keyboard-response",
  stimulus: `
    <h2>Globālais bloks</h2>
    <p>Fokusējies uz LIELAJIEM burtiem.</p>
    <p>Ignorē mazos burtiņus.</p>
    <p>H = 1, S = 2</p>
    <p>Nospied SPACE, lai sāktu.</p>
  `,
  choices: [" "],
  data: {ignore:true}
});
timeline.push(...createTrials("global", N_TRIALS_GLOBAL, "global"));

timeline.push({
  type: "html-keyboard-response",
  stimulus: `
    <h2>Lokālais bloks</h2>
    <p>Fokusējies uz MAZAJIEM burtiem.</p>
    <p>Ignorē lielos burtiņus.</p>
    <p>H = 1, S = 2</p>
    <p>Nospied SPACE, lai sāktu.</p>
  `,
  choices: [" "],
  data: {ignore:true}
});
timeline.push(...createTrials("local", N_TRIALS_LOCAL, "local"));

timeline.push({
  type: "html-keyboard-response",
  stimulus: `
    <h2>Mix bloks</h2>
    <p>Pirms katra uzdevuma ir bultiņa:</p>
    <p>↑ - fokusējies uz globālo (lielo) burtu</p>
    <p>↓ - fokusējies uz lokālo (mazo) burtu</p>
    <p>H = 1, S = 2</p>
    <p>Nospied SPACE, lai sāktu.</p>
  `,
  choices: [" "],
  data: {ignore:true}
});
timeline.push(...createTrials("mixed", N_TRIALS_MIXED));

timeline.push({
  type: "html-keyboard-response",
  stimulus: function () {

    const trials = jsPsych.data.get()
      .filterCustom(d =>
        d.trial_type === "html-keyboard-response" &&
        !d.ignore &&
        d.block
      );

    function blockAccuracy(blockName) {
      const blockTrials = trials.filter({ block: blockName });
      if (blockTrials.count() === 0) return "—";
      return Math.round(blockTrials.select("correct").mean() * 100) + "%";
    }

    const globalAcc = blockAccuracy("global");
    const localAcc  = blockAccuracy("local");
    const mixedAcc  = blockAccuracy("mixed");

    const meanRT = Math.round(
      trials.filter({ correct: 1 }).select("rt").mean()
    );

    return `
      <h2>Paldies par dalību!</h2>

      <h3>Precizitāte pa blokiem</h3>
      <p><strong>Globālais bloks:</strong> ${globalAcc}</p>
      <p><strong>Lokālais bloks:</strong> ${localAcc}</p>
      <p><strong>Mixed bloks:</strong> ${mixedAcc}</p>

      <p style="margin-top:15px;">
        <strong>Vidējais reakcijas laiks:</strong> ${meanRT} ms
      </p>
    `;
  },
  choices: jsPsych.NO_KEYS,
  data: { ignore: true }
});


jsPsych.init({
  timeline: timeline,
  on_finish: function(){
    const columns = [
      "participant_id",
      "timestamp",
      "block",
      "trial",
      "condition",
      "task",
      "global_letter",
      "local_letter",
      "response",
      "correct",
      "rt"
    ];

    const rows = jsPsych.data.get()
      .filterCustom(d => d.trial_type==="html-keyboard-response" && !d.ignore)
      .values()
      .map(r => {
        let obj = {};
        columns.forEach(c => obj[c] = r[c] ?? "");
        return obj;
      });

      fetch(GOOGLE_SHEETS_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(rows)
      });
  }
});


</script>

</body>
</html>
